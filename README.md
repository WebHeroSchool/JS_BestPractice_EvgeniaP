# JavaScript Best Practice Guide
---------------------

#### Содержание:

1. [Уменьшите количество глобальных переменных](#global-variables)
2. [Не используйте конструкцию with](#no-with)
3. [Никогда не объявляйте функции в нефункциональном блоке (if, while, и т.д.)](#no-function-in-block)
4. [Используйте === для сравнения вместо ==](#comparison)
5. [Используйте литералы для создания новых объектов и массивов](#literals)
6. [Проблема плавающих точек](#floating-point)
7. [Отдавайте предпочтение использованию оператора расширения ... при вызове вариативной функции](#spread)
8. [Избегайте схожести стрелочной функции (=>) с операторами сравнения](#arrow-function)
9. [Используйте тернарные операторы](#ternary-operators)
10. [Всегда используйте class, избегайте прямых манипуляций с prototype](#class)

---------------------
### <a name="global-variables">1. Уменьшите количество глобальных переменных</a>

Глобальные переменные будут доступны во всем коде JavaScript, поэтому существует вероятность конфликта имен, когда разные части кода будут определять глобальные переменные с одинаковым именем, но используемые для различных целей.


``` js
//плохо

let name = 'Вася';  
let lastName = 'Иванов';  
  
function doSomething() {...}
  
console.log(name); // Вася 


// хорошо
let person = {  
   name : 'Вася',  
   lastName : 'Иванов',
   
   function doSomething() {...},
}

console.log(person.name); // Вася  
```    


---------------------

###  <a name="no-with">2. Не используйте конструкцию with</a>

Конструкция with позволяет использовать в качестве области видимости для переменных произвольный объект. 
Проблемы возникают в том случае, когда в with(obj) присваивается переменная, которая по замыслу должна быть в свойствах obj, но ее там нет. Другими словами, мы не можем добавлять свойства объекту, находящемуся внутри with, а использование with определяет переменную в глобальное пространство.

Например:


``` js
const person = {
  name: "Вася",
  city: "Тула",
}

with(person) {
  city = "Москва";
  age = 23;
}

console.log(person.city); // Москва
console.log(person.age); // undefined
console.log(window.age); // 23
``` 
Когда мы присваиваиваем свойство age, отсутствующее в объекте person, интерпретатор, не найдя его, создает новую глобальную переменную window.age. Таким образом может произойти засорение глобальной области и путаница в дальнейшем

---------------------
### <a name="no-function-in-block">3. Никогда не объявляйте функции в нефункциональном блоке (if, while, и т.д.)</a>
Это может привести к ошибке, т.к. функция объявленная в блоке if, while и т.д. не существует в глобальной области. Поэтому вместо этого необходимо использовать переменную, инициализированную с помощью выражения функции.
``` js
// плохо
if (x) {
  function foo() {}
}

// хорошо
if (x) {
  var foo = function() {};
}
``` 
---------------------
### <a name="comparison">4. Используйте === для сравнения вместо ==</a>
Для сравнения в JavaScript используйте оператор ===(!==) вместо ==(!=).
Оператор == в действительности не сравнивает объекты, а пытается привести их к одному типу. К примеру, в выражении 5 == '5', строка справа конвертируется в число, и только потом сравнивается. Тогда как ===(!==) не делает такого преобразования.
Использование сравнения с преобразованием типов может привести к непредвиденным проблемам, связанным с особенностями конвертации разных типов. Например, Объекты String имеют тип Object, а не String.
```js
// Истина, так как оба операнда имеют тип String
'foo' === 'foo'

let a = new String('foo');
let b = new String('foo');

// Ложь, так как операнды являются объектами, внутренние ссылки которых, ссылаются на разные объекты в памяти
a == b 

// Ложь, так как операнды являются объектами, внутренние ссылки которых, ссылаются на разные объекты в памяти
a === b 

// Истина, так как объект a (String) будет преобразован в строку 'foo', перед сопоставлением
a == 'foo'
```

---------------------
### <a name="literals">5. Используйте литералы для создания новых объектов и массивов </a>
Не создавайте массивы через конструктор new Array. Конструкторы массивов подвержены ошибкам:
```js
// Длина массива будет равна 3.
let a1 = new Array(x1, x2, x3);

// Длина массива будет равна 2.
let a2 = new Array(x1, x2);

// Если x1 является числом и это натуральное число, длина массива будет равна x1.
// Если x1 является ненатуральным числом, то это вызовет ошибку
// В остальных случаях массив будет иметь 1 элемент
let a3 = new Array(x1);

// Длина массива будет равна 0.
let a4 = new Array();
```
Поэтому, правильнее будет создавать массивы, используя квадратные скобки:
```js
var a = [x1, x2, x3];
var a2 = [x1, x2];
var a3 = [x1];
var a4 = [];
```
У конструкторов объектов нет таких проблем, однако, для лучшей читаемости так же следует использовать фигурные скобки вместо создания объектов через конструктор new Object.
```js
// плохо
var o = new Object();

var o2 = new Object();
o2.a = 0;
o2.b = 1;
o2.c = 2;
o2['strange key'] = 3;

// хорошо
var o = {};

var o2 = {
  a: 0,
  b: 1,
  c: 2,
  'strange key': 3
};
```
---------------------
### <a name="floating-point">6. Проблема плавающих точек</a>
Все числа в JavaScript с плавающей точкой внутри представляются как 64 битные в двоичном виде по стандарту IEEE 754, поэтому если мы, например, попытаемся сложить десятичные дроби, то нас может ожидать непредсказуемый результат:
```js
console.log( 0.1 + 0.2 ); // 0.30000000000000004
```
Число 0.1 (одна десятая) записывается просто в десятичном формате. Но в двоичной системе счисления это бесконечная дробь, так как единица на десять в двоичной системе так просто не делится. Также бесконечной дробью является 0.2 (=2/10). Когда мы складываем 0.1 и 0.2, то две неточности складываются, получаем незначительную, но всё же ошибку в вычислениях.

Вы можете использовать методы toFixed() и toPrecision(), чтобы избежать подобных проблем.
```js
console.log( +( 0.1 + 0.2 ).toFixed(10)); // 0.3
console.log( +(0.1 + 0.2).toPrecision(1)); // 0.3
```

---------------------
### <a name="spread">7. Отдавайте предпочтение использованию оператора расширения ... при вызове вариативной функции</a>
Это чище, вам не нужно предоставлять контекст, и не так просто составить new с apply.
```js
// плохо
const x = [1, 2, 3, 4, 5];
console.log.apply(console, x);

// хорошо
const x = [1, 2, 3, 4, 5];
console.log(...x);

// плохо
new (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]));

// хорошо
new Date(...[2016, 8, 5]);
```

---------------------

### <a name="arrow-function">8. Избегайте схожести стрелочной функции (=>) с операторами сравнения</a>
Это приводит к тому, что код становится тяжелее читать.
```js
// плохо
const itemHeight = item => item.height <= 256 ? item.largeSize : item.smallSize;

// плохо
const itemHeight = (item) => item.height >= 256 ? item.largeSize : item.smallSize;

// хорошо
const itemHeight = item => (item.height <= 256 ? item.largeSize : item.smallSize);

// хорошо
const itemHeight = (item) => {
  const { height, largeSize, smallSize } = item;
  return height <= 256 ? largeSize : smallSize;
};
```
---------------------

### <a name="ternary-operators">9. Используйте тернарные операторы</a>
Это сокращает код. Например:
```js
// вместо этого
if (val) {
  return foo();
} else {
  return bar();
}

// можно записать так
return val ? foo() : bar();
```

---------------------

### <a name="class">10. Всегда используйте class, избегайте прямых манипуляций с prototype</a>
Синтаксис Class является более интуитивно понятным.
```js
// плохо

function User(name) {
  this.name = name;
}

User.prototype.sayHi = function() {
  alert(this.name);
}


// хорошо

class User {

  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }

}

let user = new User("Вася");
user.sayHi(); // Вася
```

---------------------
